React 学习之道

# 简介

## React 特点

* 第一代 SPA：Angular、Ember 以及 Backbone。
* React 并不是一个 SPA 框架，而是一个视图库，但围绕 React 周边的整个生态系统让构建单页面应用成为可能。
* 第一代框架尝试一次性解决很多问题，而 React 仅仅帮助你构建视图层。它更多的是一个库而非框架。其背后的思路是：应用的视图应该是一系列层次分明的可组合的组件。
* 重点关注视图层的两个优点
  * 你可以按部就班地学习 SPA 的每一部分。你不用担心要一次性理解全部。
  * SPA 的各部分都是可替换的。这样就使得 React 的周边生态圈充满新的创意。
* 第一代 SPA 框架更贴近企业级。它们缺乏足够的灵活性。
* React 生态圈组成了一个整体的灵活且可替换的框架，React 拥有简单整洁的 API、神奇的生态圈以及很棒的社区。

## node 和 npm

全局 node 包只需要一次性地安装在全局目录，可以在终端的任何地方使用。

Node 包安装完成后将会保存在 node_modules/ 文件夹里面，并且附加在会在 package.json 的依赖列表之后。

关于 package.json 额外多说一句。通过这个文件你可以在不共享本地包的情况下把项目共享给其他的开发人员。因为这个文件中已经有了所有 node 包的引用，这些包又被叫做依赖（dependency），每个人都可以在不包含所有依赖的情况下拷贝你的项目，因为 package.json 中列出了所有的依赖。只需要通过一个简单的 npm install 命令就可以获取所有依赖然后安装到 node_modules/ 文件夹下面。

基本命令

```
npm install -g <package>
npm install <package>
npm init -y
npm install --save-dev <package> # 标记表示该 node 包只是用作开发环境的一部分，并不会被作为你产品代码的一部分发布。
```

## 安装 React

1. CDN
2. NPM 包管理项目

那么我们需要使用 NPM 安装哪些包呢？

1. react
2. react-dom
3. babel：使项目支持 JSX 语法和 ES6
4. ...

这一步设置包含一堆的配置和工具，对于一个新手来说可能会感觉到不小的压力。由于这个原因，Facebook 引入了`create-react-app`作为零配置的 React 解决方案。

## create-react-app

Facebook 在 2016 年创建了这样一个零配置的 React 初始化套件。使用 create-react-app，各种工具和配置都会在后台集成，而开发人员只需要专注于实现就好。

```
npm install -g create-react-app
create-react-app myapp
```

create-react-app 创建的是一个 npm 项目。你可以通过 npm 来给你的项目安装和卸载 node 包。另外它还附带了下面几个 npm 脚本：

```
npm start
npm test
npm run build
```

这些脚本存在 package.json 中，现在这样一个 React 样板项目就创建完成了。

## JSX 简介

* 这是 React 特有的语法。
* 区分组件、实例和元素
* JSX 允许你在 JavaScript 中混入 HTML 结构。

## ES6 const 和 let

* 被 const 声明的变量不能被重新赋值或重新声明。你必须小心地使用 const 。使用 const 声明的变量不能被改变，但是如果这个变量是数组或者对象的话，它里面持有的内容可以被更新。它里面持有的内容不是不可改变的。
* let 语句声明一个块级作用域的本地变量，被关键字 let 声明的变量可以被改变。
* 不同的声明方式应该在什么时候使用呢？有很多的选择。我的建议是在任何你可以使用 const 的时候使用它。这表示尽管对象和数组的内容是可以被修改的，你仍希望保持该数据结构不可变。而如果你想要改变你的变量，就使用 let 去声明它。
* React 和它的生态是拥抱不可变的。这就是为什么 const 应该是你定义一个变量时的默认选择。

### let 深入

let 特点与 var 区别

* let 声明的变量只在其声明的块或子块中可用，这一点，与 var 相似。二者之间最主要的区别在于 var 声明的变量的作用域是整个封闭函数。
* 简化内部函数代码，当用到内部函数的时候（闭包时），let 会让你的代码更加简洁。
* 在程序或者函数的顶层，let 并不会像 var 一样在全局对象上创造一个属性。
* 在处理构造函数的时候，可以通过 let 绑定来共享一个或多个私有成员，而不使用闭包。
* 在相同的函数或块作用域内重新声明同一个变量会引发 SyntaxError。
* 在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let 声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError。
* 块作用域根据{}区别，switch-case 下如果不使用{}则会引发 SyntaxError，使用{}则不会

### const 深入

* 此声明创建一个常量，其作用域可以是全局或本地声明的块。
* 与 var 变量不同，全局常量不会变为窗口对象的属性。
* 需要一个常数的初始化器，您必须在声明的同一语句中指定它的值。
* const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。
* 一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。

## ReactDOM

ReactDOM.render() 会使用你的 JSX 来替换你的 HTML 中的一个 DOM 节点。这样你就可以很容易地把 React 集成到每一个其他的应用中。

ReactDOM.render() 总会很好地渲染你的 App 组件。你可以将一个简单的 JSX 直接用 JSX 的方式传入，而不用必须传入一个组件的实例。

## 模块热替换

用 create-react-app 创建的项目有一个优点，那就是可以让你在更改源代码的时候浏览器自动刷新页面。

模块热替换（HMR）是一个帮助你在浏览器中重新加载应用的工具，并且无需再让浏览器刷新页面。你可以在 create-react-app 中很容易地开启这个工具：在你 React 的入口文件 src/index.js 中，添加一些配置代码。

```js
if (module.hot) {
  module.hot.accept();
}
```

优势：

1. 无须刷新，重新加载
2. 保持应用的状态

## 箭头函数

箭头函数和普通函数区别与优势

* 更简介，这些函数表达式最适合用于`非方法函数`，并且它们`不能用作构造函数`。
* this 对象的不同行为
  * 普通的函数表达式总会定义它自己的 this 对象。
  * 箭头函数表达式仍然会使用包含它的语境下的 this 对象。
  * 由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响
* 箭头函数如果函数只有一个参数，你就可以移除掉参数的括号，但是如果有多个参数，你就必须保留这个括号。
* 在 ES6 的箭头函数中，你可以用简洁函数体来替换块状函数体，且简洁函数体的返回不用显示声明。
  * 加括号的函数体返回`对象字面表达式`，直接返回例如{ foo: 1 }会是 undefined，这是因为花括号({})里面的代码被解析为一系列语句
* 不绑定 arguments
  * 参数只是在封闭范围内引用相同的名称
  * 在大多数情况下，使用剩余参数是使用 arguments 对象的好选择。
* 其他
  * 支持剩余参数和默认参数
  * 同样支持参数列表解构
  * 箭头函数没有 prototype 属性。
  * yield 关键字通常不能在箭头函数中使用，因此，箭头函数不能用作生成器。
  * 箭头函数在参数和箭头之间不能换行。
  * 箭头函数也可以使用闭包

## 类

ECMAScript 2015 中引入的 JavaScript 类(classes) 实质上是 JavaScript 现有的基于原型的继承的语法糖。JavaScript 类提供了一个更简单和更清晰的语法来创建对象并处理继承。

定义类

* 类语法有两个组成部分：类表达式和类声明。
* 函数声明和类声明之间的一个重要区别是函数声明会声明提升，类声明不会。

类体和方法定义

* 类声明和类表达式的主体都执行在严格模式下，构造函数，静态方法，原型方法，getter 和 setter 都在严格模式下执行。
* 构造函数方法是一个特殊的方法，其用于创建和初始化使用一个类创建的一个对象。一个类只能拥有一个名为 “constructor”的特殊方法。一个构造函数可以使用 super 关键字来调用一个父类的构造函数。
* 原型方法
* 静态方法：static 关键字用来定义一个类的一个静态方法。调用静态方法不需要实例化该类，但不能通过一个类实例调用静态方法。静态方法通常用于为一个应用程序创建工具函数。

继承

* 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super（）。
* 类不能扩展常规（不可构造/非构造的）对象。如果要继承常规对象，可以改用 Object.setPrototypeOf():

JavaScript ES6 引入了类的概念。类通常在面向对象编程语言中被使用。JavaScript 的编程范式在过去和现在都是非常灵活的。你可以根据使用情况一边使用函数式编程一边使用面向对象编程。React 混合使用了两种编程范式中的有益的部分。

* 类都有一个用来实例化自己的构造函数。这个构造函数可以用来传入参数来赋给类的实例。
* 类可以定义函数。因为这个函数被关联给了类，所以它被称为方法。

组件类

* Component 类封装了所有 React 类需要的实现细节。它使得开发者们可以在 React 中使用类来创建组件。
* React Component 类暴露出来的方法都是公共的接口。这些方法中有一个方法必须被重写（render()），其他的则不一定要被重写。

# 基础

## 内部状态

* 使用 ES6 类组件可以在构造函数中初始化组件的状态。 构造函数只会在组件初始化时调用一次。
* 当你使用 ES6 编写的组件有一个构造函数时，它需要强制地调用 super(); 方法
* 你也可以调用 super(props);，它会在你的构造函数中设置 this.props 以供在构造函数中访问它们。 否则当在构造函数中访问 this.props ，会得到 undefined。
* 不要直接修改 state。你必须使用 setState() 方法来修改它，每次你修改组件的内部状态，组件的 render 方法会再次运行。

## ES6 对象初始化

ES6 中对象初始化比 ES5 更加简洁

* 当你的对象中的属性名与变量名相同时，可以省略变量名
* 简写方法名，eg：const obj = {func(){}}
* 使用计算属性名，eg：const user = {[key]: 'Robin',};

## 单项数据流

![单项数据流](/one-way.png)
